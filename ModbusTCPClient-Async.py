import asyncio
import logging

import argparse

import pymodbus.client as modbusClient
from pymodbus import ModbusException


_logger = logging.getLogger(__file__)
_logger.setLevel("DEBUG")

async def read_register_value(client, address):
    """Lee el valor del registro en la direcci贸n dada."""
    try:
        result = await client.read_holding_registers(address, 1, unit=1)
        return result.registers[0]
    except (ModbusIOException, ConnectionException) as e:
        _logger.error(f"Error reading register value: {e}")
        return None

async def control_actuator(client, address, value):
    """Controla el actuador en funci贸n del valor dado."""
    try:
        await client.write_coil(address, value, unit=1)
        _logger.info(f"Actuator controlled. Address: {address}, Value: {value}")
    except (ModbusIOException, ConnectionException) as e:
        _logger.error(f"Error controlling actuator: {e}")

async def run_periodic_task(client):
    """Realiza la lectura del valor del registro cada minuto y controla el actuador si es necesario."""
    while True:
        value = await read_register_value(client, 0)  # Leer valor del registro en la direcci贸n 0
        if value is not None:
            _logger.info(f"Register value: {value}")
            if value > 80:
                await control_actuator(client, 0, True)  # Encender el actuador si el valor es mayor que 80
        await asyncio.sleep(60)  # Esperar 1 minuto antes de la pr贸xima lectura

def setup_async_client(description=None, cmdline=None):
    """Run client setup."""

    parser = argparse.ArgumentParser(description="Run client.")
    parser.add_argument("--port", type=int, default=5020, help="set port")
    parser.add_argument("--comm", default="tcp", help="set communication, default is tcp")
    parser.add_argument("--framer", default="rtu", help="set framer, default is rtu")
    parser.add_argument("--log", default="info", help="set log level, default is info")
    parser.add_argument("--baudrate", type=int, default=9600, help="set serial device baud rate")
    parser.add_argument("--host", default="127.0.0.1", help="set host, default is 127.0.0.1")
    parser.add_argument("--timeout", type=float, default=1.0, help="set client timeout")
    args = parser.parse_args()

    _logger.setLevel(args.log.upper())
    _logger.info("### Create client object")
    if args.comm == "tcp":
        client = modbusClient.AsyncModbusTcpClient(
            args.host,
            port=args.port,  # on which port
            # Common optional parameters:
            framer=args.framer,
            timeout=args.timeout,
            retries=3,
            reconnect_delay=1,
            reconnect_delay_max=10,
            #    retry_on_empty=False,
            # TCP setup parameters
            #    source_address=("localhost", 0),
        )
    elif args.comm == "udp":
        client = modbusClient.AsyncModbusUdpClient(
            args.host,
            port=args.port,
            # Common optional parameters:
            framer=args.framer,
            timeout=args.timeout,
            #    retries=3,
            #    retry_on_empty=False,
            # UDP setup parameters
            #    source_address=None,
        )
    elif args.comm == "serial":
        client = modbusClient.AsyncModbusSerialClient(
            args.port,
            # Common optional parameters:
            #    framer=ModbusRtuFramer,
            timeout=args.timeout,
            #    retries=3,
            #    retry_on_empty=False,
            # Serial setup parameters
            baudrate=args.baudrate,
            #    bytesize=8,
            #    parity="N",
            #    stopbits=1,
            #    handle_local_echo=False,
            #    strict=True,
        )
    elif args.comm == "tls":
        client = modbusClient.AsyncModbusTlsClient(
            args.host,
            port=args.port,
            # Common optional parameters:
            framer=args.framer,
            timeout=args.timeout,
            #    retries=3,
            #    retry_on_empty=False,
            # TLS setup parameters
            #    sslctx=sslctx,
            certfile=helper.get_certificate("crt"),
            keyfile=helper.get_certificate("key"),
            #    password="none",
            server_hostname="localhost",
        )
    return client


async def run_async_client(client, modbus_calls=None):
    """Run sync client."""
    _logger.info("### Client starting")
    await client.connect()
    assert client.connected
    if modbus_calls:
        await modbus_calls(client)
    client.close()
    _logger.info("### End of Program")


async def run_a_few_calls(client):
    """Test connection works."""
    try:
        rr = await client.read_coils(32, 1, slave=1)
        assert len(rr.bits) == 8
        rr = await client.read_holding_registers(4, 2, slave=1)
        assert rr.registers[0] == 17
        assert rr.registers[1] == 17
    except ModbusException:
        pass


async def main(cmdline=None):
    """Combine setup and run."""
    testclient = setup_async_client(description="Run client.", cmdline=cmdline)
    await run_async_client(testclient, modbus_calls=run_periodic_task)
    


if __name__ == "__main__":
    asyncio.run(main(), debug=True)
