from scapy.all import *
import sqlite3

# Define initial constants
#SERVER_IP = '172.17.0.2'
SERVER_IP = '127.0.0.1'
SERVER_PORT = 502
#INTERFACE = 'docker0'
INTERFACE = 'lo'

# Database connection
connection = sqlite3.connect('modbus_data.db')
conn = connection.cursor()

# Create table
conn.execute('''CREATE TABLE IF NOT EXISTS modbus_data (
             id INTEGER PRIMARY KEY AUTOINCREMENT,
             packet_type TEXT,
             src_IP TEXT,
             dst_IP TEXT,
             src_PORT TEXT,
             dst_PORT TEXT,
             Transaction_Identifier TEXT,
             Protocol_Identifier TEXT,
             Length TEXT,
             Unit_Identifier TEXT,
             Function_Code TEXT,
             Reference_Number TEXT,
             Byte_Count TEXT,
             Data TEXT
             )''')

# Delete old registers
conn.execute("DELETE FROM modbus_data")
connection.commit()

# Define a callback function to process captured packets
def packet_callback(packet):
    if packet.haslayer(TCP):
        if packet[TCP].dport == 502 or packet[TCP].sport == 502:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            src_port = packet[TCP].sport
            dst_port = packet[TCP].dport
            
            #Determine if the packet is a request or a response
            if src_port == 502:
                packet_type = "Response"
            else:
                packet_type= "Request"

            # Check if Raw layer exists
            if Raw in packet:
                raw_data = bytes(packet[TCP].payload)
            else:
                raw_data = None

            print(f"Modbus packet captured to {dst_ip}:{dst_port}")
            if raw_data:
                print(f"Raw data (hexadecimal): {raw_data.hex()}")

            if raw_data:
                transaction_identifier = raw_data[:2].hex()
                protocol_identifier = raw_data[2:4].hex()
                length = raw_data[4:6].hex()
                unit_identifier = raw_data[6:7].hex()
                function_code = raw_data[7:8].hex()
                reference_number = raw_data[8:10].hex()
                byte_count = raw_data[10:12].hex()
                data = raw_data[12:].hex()
            else:
                # If there is no data, fields should be null
                transaction_identifier = protocol_identifier = length = unit_identifier = function_code = byte_count = reference_number = data = None
            

            conn.execute("SELECT id FROM modbus_data WHERE packet_type=? AND src_IP=? AND dst_IP=? AND src_PORT=? AND dst_PORT=? AND Transaction_Identifier=? AND Protocol_Identifier=? AND Length=? AND Unit_Identifier=? AND Function_Code=? AND Reference_Number=? AND Byte_Count=? AND Data=?",
                                (packet_type, src_ip, dst_ip, src_port, dst_port, transaction_identifier, protocol_identifier, length, unit_identifier, function_code, reference_number, byte_count, data))
            exist_packet = conn.fetchone()

            if protocol_identifier == "0000":
                if not exist_packet:
                    # Save info in the database
                    conn.execute("INSERT INTO modbus_data (packet_type, src_IP, dst_IP, src_PORT, dst_PORT,Transaction_Identifier, Protocol_Identifier, Length, Unit_Identifier, Function_Code, Reference_Number, Byte_Count, Data) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                                        (packet_type, src_ip, dst_ip, src_port, dst_port, transaction_identifier, protocol_identifier, length, unit_identifier, function_code, reference_number, byte_count, data))
                    connection.commit()
                else:
                    print("Duplicate entry, skipping insertion")
            else:
                print("Not a Modbus packet")

# Start sniffing on the specified interface ('docker0', 'eth0', 'lo', etc.)
sniff(iface=INTERFACE, prn=packet_callback, store=0)

